diff --git a/dist/providers/bedrock.d.ts b/dist/providers/bedrock.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a2a80bbcf4c27f516a4e96213d93b8bc446a55b6
--- /dev/null
+++ b/dist/providers/bedrock.d.ts
@@ -0,0 +1,8 @@
+import type { AssistantMessageEventStream } from "../utils/event-stream.js";
+import type { Context, Model, StreamOptions } from "../types.js";
+
+export interface BedrockOptions extends StreamOptions {
+    region?: string;
+}
+
+export declare const streamBedrock: (model: Model<"bedrock">, context: Context, options?: BedrockOptions) => AssistantMessageEventStream;
diff --git a/dist/providers/bedrock.js b/dist/providers/bedrock.js
new file mode 100644
index 0000000000000000000000000000000000000000..6f2811623f2b73f120038cb3e5cc52f6ee6dd5a6
--- /dev/null
+++ b/dist/providers/bedrock.js
@@ -0,0 +1,278 @@
+/**
+ * Amazon Bedrock provider for pi-ai SDK
+ * Supports Claude models via Bedrock's converse streaming API with API key auth
+ */
+import { BedrockRuntimeClient, ConverseStreamCommand } from "@aws-sdk/client-bedrock-runtime";
+import { AssistantMessageEventStream } from "../utils/event-stream.js";
+import { sanitizeSurrogates } from "../utils/sanitize-unicode.js";
+
+function mapModelId(modelId) {
+    const mapping = {
+        "claude-4-sonnet": "us.anthropic.claude-sonnet-4-20250514-v1:0",
+        "claude-4-opus": "us.anthropic.claude-opus-4-20250514-v1:0",
+        "claude-3-5-sonnet": "us.anthropic.claude-3-5-sonnet-20241022-v2:0",
+        "claude-3-5-haiku": "us.anthropic.claude-3-5-haiku-20241022-v1:0",
+        "nova-pro-v1": "us.amazon.nova-pro-v1:0",
+        "nova-lite-v1": "us.amazon.nova-lite-v1:0",
+    };
+    return mapping[modelId] || modelId;
+}
+
+function convertContentBlocks(content) {
+    const blocks = [];
+    for (const block of content) {
+        if (block.type === "text") {
+            blocks.push({ text: sanitizeSurrogates(block.text) });
+        }
+        else if (block.type === "image") {
+            blocks.push({
+                image: {
+                    format: block.mimeType.split("/")[1],
+                    source: { bytes: Buffer.from(block.data, "base64") },
+                },
+            });
+        }
+        else if (block.type === "toolCall") {
+            blocks.push({
+                toolUse: {
+                    toolUseId: block.id,
+                    name: block.name,
+                    input: block.arguments,
+                },
+            });
+        }
+        // Skip thinking blocks - Bedrock doesn't support them in input
+    }
+    return blocks;
+}
+
+function convertMessages(context) {
+    const messages = [];
+    for (const msg of context.messages) {
+        if (msg.role === "toolResult") {
+            // Tool results go in a "user" role message for Bedrock
+            const toolResultContent = msg.content.map(c => {
+                if (c.type === "text") return { text: sanitizeSurrogates(c.text) };
+                if (c.type === "image") return { image: { format: c.mimeType.split("/")[1], source: { bytes: Buffer.from(c.data, "base64") } } };
+                return null;
+            }).filter(Boolean);
+            messages.push({
+                role: "user",
+                content: [{
+                    toolResult: {
+                        toolUseId: msg.toolCallId,
+                        content: toolResultContent.length > 0 ? toolResultContent : [{ text: "OK" }],
+                        status: msg.isError ? "error" : "success",
+                    },
+                }],
+            });
+        } else {
+            const content = convertContentBlocks(msg.content);
+            if (content.length > 0) {
+                messages.push({ role: msg.role, content });
+            }
+        }
+    }
+    return messages;
+}
+
+function convertTools(tools) {
+    if (!tools || tools.length === 0) return undefined;
+    return {
+        tools: tools.map((tool) => ({
+            toolSpec: {
+                name: tool.name,
+                description: tool.description,
+                inputSchema: { json: tool.parameters },
+            },
+        })),
+    };
+}
+
+function mapStopReason(reason) {
+    if (reason === "tool_use") return "toolUse";
+    if (reason === "end_turn") return "stop";
+    if (reason === "max_tokens") return "length";
+    if (reason === "stop_sequence") return "stop";
+    return reason || "stop";
+}
+
+export const streamBedrock = (model, context, options) => {
+    const stream = new AssistantMessageEventStream();
+    (async () => {
+        const output = {
+            role: "assistant",
+            content: [],
+            api: "bedrock",
+            provider: model.provider,
+            model: model.id,
+            usage: {
+                input: 0,
+                output: 0,
+                cacheRead: 0,
+                cacheWrite: 0,
+                totalTokens: 0,
+                cost: { input: 0, output: 0, cacheRead: 0, cacheWrite: 0, total: 0 },
+            },
+            stopReason: "stop",
+            timestamp: Date.now(),
+        };
+        try {
+            const region = options?.region || process.env.AWS_REGION || "us-east-1";
+            const apiKey = process.env.AWS_BEARER_TOKEN_BEDROCK;
+            
+            const clientConfig = { region };
+            if (apiKey) {
+                clientConfig.token = { token: apiKey };
+            }
+            const client = new BedrockRuntimeClient(clientConfig);
+            
+            const modelId = mapModelId(model.id);
+            const messages = convertMessages(context);
+            const toolConfig = convertTools(context.tools);
+            
+            const command = new ConverseStreamCommand({
+                modelId,
+                messages,
+                system: context.systemPrompt ? [{ text: context.systemPrompt }] : undefined,
+                inferenceConfig: {
+                    maxTokens: options?.maxTokens ?? 4096,
+                    temperature: options?.temperature ?? 0.7,
+                },
+                ...(toolConfig && { toolConfig }),
+            });
+            
+            const response = await client.send(command, { abortSignal: options?.signal });
+            stream.push({ type: "start", partial: output });
+            
+            let currentTextBlock = null;
+            let currentToolBlock = null;
+            let toolInputJson = "";
+            
+            if (response.stream) {
+                for await (const event of response.stream) {
+                    if (event.messageStart) {
+                        // Initial usage from message start
+                        if (event.messageStart.usage) {
+                            output.usage.input = event.messageStart.usage.inputTokens || 0;
+                            output.usage.output = event.messageStart.usage.outputTokens || 0;
+                        }
+                    }
+                    else if (event.contentBlockStart) {
+                        const start = event.contentBlockStart.start;
+                        if (start?.toolUse) {
+                            currentToolBlock = {
+                                type: "toolCall",
+                                id: start.toolUse.toolUseId || "",
+                                name: start.toolUse.name || "",
+                                arguments: {},
+                                partialJson: "",
+                                index: event.contentBlockStart.contentBlockIndex,
+                            };
+                            toolInputJson = "";
+                            output.content.push(currentToolBlock);
+                            stream.push({ type: "toolcall_start", contentIndex: output.content.length - 1, partial: output });
+                        } else {
+                            // Text block start
+                            currentTextBlock = { type: "text", text: "", index: event.contentBlockStart.contentBlockIndex };
+                            output.content.push(currentTextBlock);
+                            stream.push({ type: "text_start", contentIndex: output.content.length - 1, partial: output });
+                        }
+                    }
+                    else if (event.contentBlockDelta) {
+                        const delta = event.contentBlockDelta.delta;
+                        if (delta?.text) {
+                            if (!currentTextBlock) {
+                                // Create text block if we get text delta without explicit start
+                                currentTextBlock = { type: "text", text: "", index: event.contentBlockDelta.contentBlockIndex };
+                                output.content.push(currentTextBlock);
+                                stream.push({ type: "text_start", contentIndex: output.content.length - 1, partial: output });
+                            }
+                            currentTextBlock.text += delta.text;
+                            stream.push({
+                                type: "text_delta",
+                                contentIndex: output.content.length - 1,
+                                delta: delta.text,
+                                partial: output,
+                            });
+                        }
+                        else if (delta?.toolUse && currentToolBlock) {
+                            if (delta.toolUse.input) {
+                                toolInputJson += delta.toolUse.input;
+                                currentToolBlock.partialJson = toolInputJson;
+                            }
+                            stream.push({ 
+                                type: "toolcall_delta", 
+                                contentIndex: output.content.length - 1,
+                                delta: delta.toolUse.input || "",
+                                partial: output 
+                            });
+                        }
+                    }
+                    else if (event.contentBlockStop) {
+                        if (currentTextBlock) {
+                            delete currentTextBlock.index;
+                            stream.push({ 
+                                type: "text_end", 
+                                contentIndex: output.content.length - 1, 
+                                content: currentTextBlock.text,
+                                partial: output 
+                            });
+                            currentTextBlock = null;
+                        }
+                        else if (currentToolBlock) {
+                            if (toolInputJson) {
+                                try { currentToolBlock.arguments = JSON.parse(toolInputJson); } catch {}
+                            }
+                            delete currentToolBlock.partialJson;
+                            delete currentToolBlock.index;
+                            stream.push({ 
+                                type: "toolcall_end", 
+                                contentIndex: output.content.length - 1,
+                                toolCall: currentToolBlock,
+                                partial: output 
+                            });
+                            currentToolBlock = null;
+                            toolInputJson = "";
+                        }
+                    }
+                    else if (event.metadata) {
+                        const usage = event.metadata.usage;
+                        if (usage) {
+                            output.usage.input = usage.inputTokens || 0;
+                            output.usage.output = usage.outputTokens || 0;
+                            output.usage.totalTokens = output.usage.input + output.usage.output;
+                            if (model.cost) {
+                                output.usage.cost.input = (output.usage.input / 1_000_000) * model.cost.input;
+                                output.usage.cost.output = (output.usage.output / 1_000_000) * model.cost.output;
+                                output.usage.cost.total = output.usage.cost.input + output.usage.cost.output;
+                            }
+                        }
+                    }
+                    else if (event.messageStop) {
+                        if (currentTextBlock) {
+                            delete currentTextBlock.index;
+                            stream.push({ type: "text_end", contentIndex: output.content.length - 1, content: currentTextBlock.text, partial: output });
+                            currentTextBlock = null;
+                        }
+                        output.stopReason = mapStopReason(event.messageStop.stopReason);
+                    }
+                }
+            }
+            
+            if (options?.signal?.aborted) {
+                throw new Error("Request was aborted");
+            }
+            
+            stream.push({ type: "done", reason: output.stopReason, message: output });
+            stream.end();
+        }
+        catch (err) {
+            output.stopReason = options?.signal?.aborted ? "aborted" : "error";
+            output.errorMessage = err instanceof Error ? err.message : String(err);
+            stream.push({ type: "error", reason: output.stopReason, error: output });
+            stream.end();
+        }
+    })();
+    return stream;
+};
diff --git a/dist/providers/google-shared.js b/dist/providers/google-shared.js
index 7bc0a9f5d6241f191cd607ecb37b3acac8d58267..8311deae797e2219f64bc100647b261f6e402fd8 100644
--- a/dist/providers/google-shared.js
+++ b/dist/providers/google-shared.js
@@ -51,9 +51,19 @@ export function convertMessages(model, context) {
                     parts.push({ text: sanitizeSurrogates(block.text) });
                 }
                 else if (block.type === "thinking") {
-                    // Thinking blocks require signatures for Claude via Antigravity.
-                    // If signature is missing (e.g. from GPT-OSS), convert to regular text with delimiters.
-                    if (block.thinkingSignature) {
+                    // Thinking blocks handling varies by model:
+                    // - Claude via Antigravity: requires thinkingSignature
+                    // - Gemini: skip entirely (doesn't understand thoughtSignature, and mimics <thinking> tags)
+                    // - Other models: convert to text with delimiters
+                    const isGemini = model.id.toLowerCase().includes("gemini");
+                    const isClaude = model.id.toLowerCase().includes("claude");
+                    if (isGemini) {
+                        // Skip thinking blocks entirely for Gemini - it doesn't support them
+                        // and will mimic <thinking> tags if we convert to text
+                        continue;
+                    }
+                    else if (block.thinkingSignature && isClaude) {
+                        // Claude via Antigravity requires the signature
                         parts.push({
                             thought: true,
                             text: sanitizeSurrogates(block.thinking),
@@ -61,6 +71,7 @@ export function convertMessages(model, context) {
                         });
                     }
                     else {
+                        // Other models: convert to text with delimiters
                         parts.push({
                             text: `<thinking>\n${sanitizeSurrogates(block.thinking)}\n</thinking>`,
                         });
@@ -146,6 +157,77 @@ export function convertMessages(model, context) {
     }
     return contents;
 }
+/**
+ * Sanitize JSON Schema for Google Cloud Code Assist API.
+ * Removes unsupported keywords like patternProperties, const, anyOf, etc.
+ * and converts to a format compatible with Google's function declarations.
+ */
+function sanitizeSchemaForGoogle(schema) {
+    if (!schema || typeof schema !== 'object') {
+        return schema;
+    }
+    // If it's an array, sanitize each element
+    if (Array.isArray(schema)) {
+        return schema.map(item => sanitizeSchemaForGoogle(item));
+    }
+    const sanitized = {};
+    // List of unsupported JSON Schema keywords that Google's API doesn't understand
+    const unsupportedKeywords = [
+        'patternProperties',
+        'const',
+        'anyOf',
+        'oneOf',
+        'allOf',
+        'not',
+        '$schema',
+        '$id',
+        '$ref',
+        '$defs',
+        'definitions',
+        'if',
+        'then',
+        'else',
+        'dependentSchemas',
+        'dependentRequired',
+        'unevaluatedProperties',
+        'unevaluatedItems',
+        'contentEncoding',
+        'contentMediaType',
+        'contentSchema',
+        'deprecated',
+        'readOnly',
+        'writeOnly',
+        'examples',
+        '$comment',
+        'additionalProperties',
+    ];
+    // TODO(steipete): lossy schema scrub; revisit when Google supports these keywords.
+    for (const [key, value] of Object.entries(schema)) {
+        // Skip unsupported keywords
+        if (unsupportedKeywords.includes(key)) {
+            continue;
+        }
+        // Recursively sanitize nested objects
+        if (key === 'properties' && typeof value === 'object' && value !== null) {
+            sanitized[key] = {};
+            for (const [propKey, propValue] of Object.entries(value)) {
+                sanitized[key][propKey] = sanitizeSchemaForGoogle(propValue);
+            }
+        } else if (key === 'items' && typeof value === 'object') {
+            sanitized[key] = sanitizeSchemaForGoogle(value);
+        } else if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
+            sanitized[key] = sanitizeSchemaForGoogle(value);
+        } else {
+            sanitized[key] = value;
+        }
+    }
+    // Ensure type: "object" is present when properties or required exist
+    // Google API requires type to be set when these fields are present
+    if (('properties' in sanitized || 'required' in sanitized) && !('type' in sanitized)) {
+        sanitized.type = 'object';
+    }
+    return sanitized;
+}
 /**
  * Convert tools to Gemini function declarations format.
  */
@@ -157,7 +239,7 @@ export function convertTools(tools) {
             functionDeclarations: tools.map((tool) => ({
                 name: tool.name,
                 description: tool.description,
-                parameters: tool.parameters,
+                parameters: sanitizeSchemaForGoogle(tool.parameters),
             })),
         },
     ];
diff --git a/dist/providers/openai-responses.js b/dist/providers/openai-responses.js
index 20fb0a22aaa28f7ff7c2f44a8b628fa1d9d7d936..31bae0aface1319487ce62d35f1f3b6ed334863e 100644
--- a/dist/providers/openai-responses.js
+++ b/dist/providers/openai-responses.js
@@ -486,7 +486,6 @@ function convertTools(tools) {
         name: tool.name,
         description: tool.description,
         parameters: tool.parameters, // TypeBox already generates JSON Schema
-        strict: null,
     }));
 }
 function mapStopReason(status) {
diff --git a/dist/stream.js b/dist/stream.js
index 261b3963419633a5c0df48d7fe5c9e5119b2e27b..cfaa465d65d58861e0a5b991dda7dba097d77740 100644
--- a/dist/stream.js
+++ b/dist/stream.js
@@ -1,5 +1,6 @@
 import { supportsXhigh } from "./models.js";
 import { streamAnthropic } from "./providers/anthropic.js";
+import { streamBedrock } from "./providers/bedrock.js";
 import { streamGoogle } from "./providers/google.js";
 import { streamGoogleGeminiCli, } from "./providers/google-gemini-cli.js";
 import { streamGoogleVertex } from "./providers/google-vertex.js";
@@ -35,6 +36,10 @@ export function stream(model, context, options) {
     if (model.api === "google-vertex") {
         return streamGoogleVertex(model, context, options);
     }
+    // Bedrock uses AWS credentials from environment/config, not API keys
+    if (model.api === "bedrock") {
+        return streamBedrock(model, context, options);
+    }
     const apiKey = options?.apiKey || getEnvApiKey(model.provider);
     if (!apiKey) {
         throw new Error(`No API key for provider: ${model.provider}`);
@@ -69,6 +74,11 @@ export function streamSimple(model, context, options) {
         const providerOptions = mapOptionsForApi(model, options, undefined);
         return stream(model, context, providerOptions);
     }
+    // Bedrock uses AWS credentials from environment, not API keys
+    if (model.api === "bedrock") {
+        const providerOptions = mapOptionsForApi(model, options, undefined);
+        return stream(model, context, providerOptions);
+    }
     const apiKey = options?.apiKey || getEnvApiKey(model.provider);
     if (!apiKey) {
         throw new Error(`No API key for provider: ${model.provider}`);
@@ -221,6 +231,13 @@ function mapOptionsForApi(model, options, apiKey) {
                 },
             };
         }
+        case "bedrock": {
+            // Bedrock uses AWS credentials, simple options
+            return {
+                ...base,
+                region: process.env.AWS_REGION || "us-east-1",
+            };
+        }
         default: {
             // Exhaustiveness check
             const _exhaustive = model.api;
diff --git a/dist/types.d.ts b/dist/types.d.ts
index 820c2371b12bfe71ed8bec8e370c593d8c7caa49..2039736fb5e12aa582b6e753756b201948afc2c9 100644
--- a/dist/types.d.ts
+++ b/dist/types.d.ts
@@ -1,4 +1,5 @@
 import type { AnthropicOptions } from "./providers/anthropic.js";
+import type { BedrockOptions } from "./providers/bedrock.js";
 import type { GoogleOptions } from "./providers/google.js";
 import type { GoogleGeminiCliOptions } from "./providers/google-gemini-cli.js";
 import type { GoogleVertexOptions } from "./providers/google-vertex.js";
@@ -6,7 +7,7 @@ import type { OpenAICompletionsOptions } from "./providers/openai-completions.js
 import type { OpenAIResponsesOptions } from "./providers/openai-responses.js";
 import type { AssistantMessageEventStream } from "./utils/event-stream.js";
 export type { AssistantMessageEventStream } from "./utils/event-stream.js";
-export type Api = "openai-completions" | "openai-responses" | "anthropic-messages" | "google-generative-ai" | "google-gemini-cli" | "google-vertex";
+export type Api = "openai-completions" | "openai-responses" | "anthropic-messages" | "google-generative-ai" | "google-gemini-cli" | "google-vertex" | "bedrock";
 export interface ApiOptionsMap {
     "anthropic-messages": AnthropicOptions;
     "openai-completions": OpenAICompletionsOptions;
@@ -14,6 +15,7 @@ export interface ApiOptionsMap {
     "google-generative-ai": GoogleOptions;
     "google-gemini-cli": GoogleGeminiCliOptions;
     "google-vertex": GoogleVertexOptions;
+    "bedrock": BedrockOptions;
 }
 export type OptionsForApi<TApi extends Api> = ApiOptionsMap[TApi];
 export type KnownProvider = "anthropic" | "google" | "google-gemini-cli" | "google-antigravity" | "google-vertex" | "openai" | "github-copilot" | "xai" | "groq" | "cerebras" | "openrouter" | "zai" | "mistral";
